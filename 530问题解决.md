---
title: 'NotionNext 构建失败？一文彻底解决 530 错误'
date: 2025-10-09
tags: ['NotionNext', 'Debug', 'CI/CD', '530 Error', 'GitHub Actions']
summary: '详细记录了在 GitHub Actions 中构建 NotionNext 项目时，遭遇 Notion API 返回 530 错误的全过程。从环境变量配置的多次尝试，到最终定位并修复应用层代码的深层 Bug，提供了一套完整的排错思路和最终解决方案。'
---

## 前言：构建流程中的“拦路虎”

最近，在通过 GitHub Actions 自动部署我的 NotionNext 博客时，CI/CD 流水线突然开始频繁亮起红灯。检查日志后，一个刺眼的错误反复出现：

```log
Request failed with status code 530: POST https://www.notion.so/api/v3/queryCollection?src=initial_load
```

这个 `530` 错误通常与服务器端的问题有关，它表明我们的构建服务器在尝试从 Notion 拉取数据时，被 Notion 的官方 API 端点拒绝或无法连接。这很可能是由于 Notion 官方服务器的访问限制或网络不稳定导致的。

幸运的是，NotionNext 社区已经意识到了这个问题，并提供了一个官方的“补丁”思路。

## 官方补丁与“想当然”的初次尝试

社区的解决方案指出，我们可以通过设置一个名为 `API_BASE_URL` 的环境变量，将 API 请求从不稳定的官方地址 `www.notion.so` 重定向到我们自己的、更稳定的个性化 Notion 域名。

我的个性化域名是 `https://dune-adapter-6ae.notion.site`，因此我需要在项目中配置一个新的 API 端点：`https://dune-adapter-6ae.notion.site/api/v3`。

看起来很简单，对吗？于是我开始了第一次尝试。

### 步骤 1：修改 `blog.config.js`

首先，我让代码能够识别这个新的环境变量。

```javascript
// blog.config.js

const BLOG = {
  // ... 其他配置
  API_BASE_URL: process.env.API_BASE_URL || 'https://www.notion.so/api/v3', // 如果环境变量不存在，则使用默认地址
  // ...
}
```

### 步骤 2：在 GitHub Actions 中设置 Secret

然后，我在 GitHub 仓库的 `Settings -> Secrets and variables -> Actions` 中，添加了一个名为 `API_BASE_URL` 的 Secret，并填入我的新地址。

[此处可以插入 GitHub 设置 Secret 的截图]

### 步骤 3：修改工作流文件

最后，我在 `.github/workflows/deploy-to-domestic.yml` 文件中，将这个 Secret 注入到构建环境中。

```yaml
// .github/workflows/deploy-to-domestic.yml

      - name: Build static files
        run: npm run export
        env:
          # ... 其他环境变量
          API_BASE_URL: ${{ secrets.API_BASE_URL }}
```

我满怀信心地提交了代码，等待着流水线变绿。然而，现实给了我沉重一击——构建依然失败，错误还是那个熟悉的 `530`。日志显示，请求依然顽固地发往了旧的 `notion.so` 地址。

## 漫长但严谨的排错之旅

一次失败并不可怕。这标志着一次深度调试的开始。

### 怀疑 1：环境变量传递链问题？

我的第一反应是，`API_BASE_URL` 变量可能在 `npm` 脚本的执行过程中“丢失”了。

*   **尝试 A**：我尝试使用 `KEY=VALUE command` 的方式，在执行命令时直接注入变量。
    ```yaml
    run: API_BASE_URL=${{ secrets.API_BASE_URL }} npm run export
    ```
    **结果**：失败。

*   **尝试 B**：我怀疑是 `npm run` 或者脚本中的 `cross-env` 工具搞的鬼。我决定绕过它们，直接在工作流中执行 `npm run export` 背后的命令。
    ```yaml
    run: |
      npx next build
      npx next-sitemap --config next-sitemap.config.js
      node scripts/merge-sitemap.js
    ```
    （注意：这里需要用 `npx`，否则会因为找不到 `next` 命令而报 `command not found` 错误。）

    **结果**：依然失败！错误还是 `530`，请求地址还是旧的！

[此处可以插入 GitHub Actions 多次失败的日志截图]

至此，我几乎可以断定：**问题不在于环境变量的传递，而在于应用程序本身！** 我们把“钥匙”准备好了，但“锁”似乎从未打算使用它。

### 怀疑 2：代码压根没用这个变量？

既然所有环境配置的努力都宣告失败，唯一的可能就是代码实现上存在问题。我把目光投向了项目源码。

通过在项目中搜索 `notion-client` 这个关键词，我很快定位到了一个关键文件：`lib/notion/getNotionAPI.js`。它的作用正是初始化与 Notion 通信的 API 客户端。

## 最终的解决方案：直击代码根源

打开 `lib/notion/getNotionAPI.js`，真相大白。

**修改前**的代码是这样的：
```javascript
// lib/notion/getNotionAPI.js

import { NotionAPI as NotionLibrary } from 'notion-client'
import BLOG from '@/blog.config'

// ...

function getNotionAPI() {
  return new NotionLibrary({
    activeUser: BLOG.NOTION_ACTIVE_USER || null,
    authToken: BLOG.NOTION_TOKEN_V2 || null,
    userTimeZone: Intl.DateTimeFormat().resolvedOptions().timeZone,
    // ... 其他配置
  })
}
```
问题一目了然：在初始化 `NotionAPI` 客户端时，代码只传递了用户、令牌等信息，**完全没有传递我们辛辛苦苦配置的 `API_BASE_URL`**！

`notion-client` 这个库需要一个名为 `apiBaseUrl` 的参数来指定 API 地址。由于代码中没有提供，它就只能一直使用自己内部硬编码的默认地址。

最终的修复方案，只需要加一行代码：

```diff
// lib/notion/getNotionAPI.js

function getNotionAPI() {
  return new NotionLibrary({
+   apiBaseUrl: BLOG.API_BASE_URL,
    activeUser: BLOG.NOTION_ACTIVE_USER || null,
    authToken: BLOG.NOTION_TOKEN_V2 || null,
    userTimeZone: Intl.DateTimeFormat().resolvedOptions().timeZone,
    // ...
  })
}
```

这行代码像一座桥梁，终于将我们在 `blog.config.js` 中读取的环境变量，与实际的 API 客户端连接了起来。

提交这次修改后，GitHub Actions 的流水线终于亮起了久违的绿色。

[此处可以插入构建成功的截图]

## 总结

这次 `530` 错误的解决过程，是一次非常经典的、从环境配置深入到应用层代码的调试之旅。它告诉我们：

1.  **官方文档并非万能**：它提供了正确的方向，但可能没有覆盖到特定版本或特定场景下的代码实现细节。
2.  **系统性排错至关重要**：当遇到看似是环境的问题时，如果多次尝试均失败，要敢于怀疑问题出在代码本身。通过“假设-验证-排除”的循环，才能一步步逼近问题的根源。
3.  **深入源码是终极武器**：当所有外部手段都失效时，直接阅读源码是解决问题的最可靠方法。

经过这一番折腾，我的博客终于恢复了自动构建。希望这篇文章能帮助遇到同样问题的你，少走一些弯路，更快地定位并解决问题。