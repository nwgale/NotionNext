const fs = require('fs').promises;
const { parseStringPromise } = require('xml2js');
const { SitemapStream, streamToPromise } = require('sitemap');
const { Readable } = require('stream');
const axios = require('axios');

const EXTERNAL_PATHS_URL = 'https://tianfei.chat/app/sitemap-paths.txt';

// The path to the sitemap file.
// NOTE: It has been verified that `next-sitemap`, despite `sitemapBaseFileName` configuration,
// only generates 'sitemap.xml' in our build environment.
// This script reads this file as an intermediate product, merges it with external paths,
// and then overwrites it with the final, complete sitemap.
const SITEMAP_PATH = './out/sitemap.xml';

// Use the canonical domain from env var if available, which is set during build
const SITE_URL = process.env.NEXT_PUBLIC_CANONICAL_DOMAIN || 'https://tianfei.chat';

async function mergeSitemaps() {
  try {
    console.log('[merge-sitemap] Starting merge process...');

    // 1. Read the intermediate sitemap generated by next-sitemap.
    // This file contains only the internal URLs discovered during the build.
    console.log(`[merge-sitemap] Reading internal sitemap from ${SITEMAP_PATH}`);
    const internalSitemapXml = await fs.readFile(SITEMAP_PATH, 'utf-8');
    const internalSitemapJson = await parseStringPromise(internalSitemapXml);
    // Handle case where urlset or url might not exist in an empty/broken sitemap
    const internalUrls = internalSitemapJson?.urlset?.url?.map(u => {
        // Convert absolute URL from next-sitemap to relative path
        const urlObject = new URL(u.loc[0]);
        const relPath = urlObject.pathname;
        const lastmod = u.lastmod?.[0];

        // Debug log to inspect the lastmod value from the intermediate sitemap
        if (relPath.startsWith('/article/')) {
          console.log(`[Merge Sitemap Debug] Path: ${relPath}, Lastmod from intermediate file: ${lastmod}`);
        }

        return {
            url: relPath, // This gives the relative path e.g., '/archive'
            lastmod: lastmod,
            changefreq: u.changefreq?.[0],
            priority: u.priority?.[0],
        }
    }) || [];
    console.log(`[merge-sitemap] Found and processed ${internalUrls.length} internal URLs.`);

    // 2. Fetch and process external paths
    console.log(`[merge-sitemap] Fetching external paths from ${EXTERNAL_PATHS_URL}`);
    const response = await axios.get(EXTERNAL_PATHS_URL);
    const externalPathsText = response.data;
    const externalLines = externalPathsText.split('\n').filter(p => p.trim() !== '' && !p.startsWith('#'));

    const externalUrls = externalLines.map(line => {
      const [path, lastmod] = line.split('|');
      // The new format is path|lastmod_iso_string.
      // We use the provided lastmod for better SEO.
      return {
        url: path,
        changefreq: 'daily',
        priority: 0.7,
        lastmod, // Directly use the ISO 8601 date string from the file
      };
    });
    console.log(`[merge-sitemap] Found and processed ${externalUrls.length} external URLs.`);

    // 3. Merge URLs
    const allUrls = [...internalUrls, ...externalUrls];
    console.log(`[merge-sitemap] Total URLs to be included: ${allUrls.length}`);

    // 4. Generate new sitemap and overwrite the old one
    const stream = new SitemapStream({ hostname: SITE_URL });
    const finalSitemapXml = (await streamToPromise(Readable.from(allUrls).pipe(stream))).toString();

    await fs.writeFile(SITEMAP_PATH, finalSitemapXml);
    console.log(`[merge-sitemap] Successfully overwrote ${SITEMAP_PATH} with merged content.`);

  } catch (error) {
    console.error('[merge-sitemap] An error occurred:', error);
    process.exit(1); // Exit with an error code to fail the build
  }
}

mergeSitemaps();