const fs = require('fs').promises;
const { parseStringPromise } = require('xml2js');
const { SitemapStream, streamToPromise } = require('sitemap');
const { Readable } = require('stream');
const axios = require('axios');

const EXTERNAL_PATHS_URL = 'https://tianfei.chat/app/sitemap-paths.txt';
const SITEMAP_PATH = './out/sitemap.xml';
// Use the canonical domain from env var if available, which is set during build
const SITE_URL = process.env.NEXT_PUBLIC_CANONICAL_DOMAIN || 'https://tianfei.chat';

async function mergeSitemaps() {
  try {
    console.log('[merge-sitemap] Starting merge process...');

    // 1. Read internal paths from the file generated by next-sitemap
    console.log(`[merge-sitemap] Reading internal sitemap from ${SITEMAP_PATH}`);
    const internalSitemapXml = await fs.readFile(SITEMAP_PATH, 'utf-8');
    const internalSitemapJson = await parseStringPromise(internalSitemapXml);
    // Handle case where urlset or url might not exist in an empty/broken sitemap
    const internalUrls = internalSitemapJson?.urlset?.url?.map(u => {
        // Convert absolute URL from next-sitemap to relative path
        const urlObject = new URL(u.loc[0]);
        return {
            url: urlObject.pathname, // This gives the relative path e.g., '/archive'
            lastmod: u.lastmod?.[0],
            changefreq: u.changefreq?.[0],
            priority: u.priority?.[0],
        }
    }) || [];
    console.log(`[merge-sitemap] Found and processed ${internalUrls.length} internal URLs.`);

    // 2. Fetch external paths
    console.log(`[merge-sitemap] Fetching external paths from ${EXTERNAL_PATHS_URL}`);
    const response = await axios.get(EXTERNAL_PATHS_URL);
    const externalPathsText = response.data;
    const externalRelativePaths = externalPathsText.split('\n').filter(p => p.trim() !== '' && !p.startsWith('#'));
    const externalUrls = externalRelativePaths.map(path => ({
      url: path, // Already a relative path
      changefreq: 'daily',
      priority: 0.7,
      lastmod: new Date().toISOString().split('T')[0],
    }));
    console.log(`[merge-sitemap] Found ${externalUrls.length} external URLs.`);

    // 3. Merge URLs
    const allUrls = [...internalUrls, ...externalUrls];
    console.log(`[merge-sitemap] Total URLs to be included: ${allUrls.length}`);

    // 4. Generate new sitemap and overwrite the old one
    const stream = new SitemapStream({ hostname: SITE_URL });
    const finalSitemapXml = (await streamToPromise(Readable.from(allUrls).pipe(stream))).toString();

    await fs.writeFile(SITEMAP_PATH, finalSitemapXml);
    console.log(`[merge-sitemap] Successfully overwrote ${SITEMAP_PATH} with merged content.`);

  } catch (error) {
    console.error('[merge-sitemap] An error occurred:', error);
    process.exit(1); // Exit with an error code to fail the build
  }
}

mergeSitemaps();